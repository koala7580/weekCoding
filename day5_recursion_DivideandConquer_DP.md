# 一、 递归  
## 1. 定义
递归算法是一种直接或者间接调用自身函数或者方法的算法。  
实质是把问题分解成 **规模缩小的同类问题的子问题** ，然后递归调用方法来比碍事问题的解，有如下特点：
 - 一个问题的解可以分解为几个子问题的解
 - 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
 - 存在递归终止条件，即必须有一个明确的递归结束条件，称之为递归出口
## 2. 求解示例
**2.1数组求和**
```
Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1]) #拆分为子问题
Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1])
……
Sum(arr[n-1...n-1] ) = arr[n-1] + Sum([])       #基本问题
```

**2.2汉诺塔问题**
 - 限制：一次只能移动一个盘； 小盘要在大盘之上。
 - 做法：将n-1个盘子看做一个整体，即要求的子问题。
 
    (1) 借助B塔，将A上的n-1个盘子从A移到B；

    (2) 将A塔最大的盘子移到C塔，A变为空塔，相当于（1）中的中间塔B塔；

    (3) 交换塔 A<->B ，目标塔依旧是C，继续上面的（1）（2），直到盘子全部移到C塔。

    *note*：交换A、B塔是为了保证问题求解的一致性。
    
**2.3爬台阶问题**

公式：

```f(n) = f(n-1)+f(n-2)```

终止条件：

 - 一个台阶：爬一个台阶
 - 两个台阶：一次走完；或两步来爬

```
f(1) = 1;
f(2) = 2;
f(n) = f(n-1)+f(n-2)
```

递归代码：

```python
def f(n):
  if n == 1:
      return 1
  if n == 2:
      return 2
  return f(n-1) + f(n-2)
  
```

## 3. 总结 如何写递归代码

```
(1) 找到如何将大问题分解为小问题的规律
(2) 通过规律写出递推公式
(3) 通过递推公式的临界点推敲出终止代码
(4) 将递推公式和终止条件翻译为代码
```

*参考链接*
[递归与动态规划](https://juejin.im/post/5c2308abf265da615304ce41)

# 二、 分治  
## 1. 定义
分治(Divide and Conquer)即“分而治之”，把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……

## 2. 基本思想与策略
 - 设计思想：将一个难以直接解决的大问题，分割成一些**规模较小的相同问题**，以便各个击破，分而治之。
 
 - 分治策略：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题**互相独立且与原问题形式相同**，**递归地解这些子问题**，然后将各子问题的解合并得到原问题的解。
 
## 3. 使用情况
分治法所能解决的问题一般具有以下几个特征：

    1) 该问题的规模 【缩小到一定的程度就可以容易地解决】      
       #绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加

    2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有 【最优子结构性质】。  
       #是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用

    3) 利用该问题分解出的子问题的解可以 【合并】 为该问题的解；  
       #关键，能否利用分治法完全取决于问题是否具有本特征。如果具备了一、二特征，而不具备本特征，则可以考虑用贪心法或动态规划法。

    4) 该问题所分解出的 【各个子问题是相互独立】 的，即子问题之间不包含公共的子问题。 
       #涉及到分治法的效率，若各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽可用分治法，但一般用动态规划法较好。

## 4.基本步骤
分治法在每一层递归上都有三个步骤：

    step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

    step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

    step3 合并：将各个子问题的解合并为原问题的解。

它的一般的算法设计模式如下：
```python
def Divide_and_Conquer(p):
  if |p| <= n0:
    return Adhoc(p)
    
  divide p into smaller problem:p1, p2, … ,pk
  
  for i in range(1, k):
    yi = Divide_and_Conquer(pi)
    
  T = Merge(y1, y2, … , yk)
  
  return T
```

 - 其中 |P| 表示问题 P 的规模；
 - n0 为一阈值，表示当问题 P 的规模不超过 n0 时，问题已容易直接解出，不必再继续分解。
 - Adhoc(P) 是该分治法中的基本子算法，用于直接解小规模的问题 P。因此，当 P 的规模不超过 n0 时直接用算法 Adhoc(P) 求解。
 - 算法 Merge(y1,y2,...,yk) 是该分治法中的合并子算法，用于将 P 的子问题 P1 ,P2 ,...,Pk 的相应的解 y1,y2,...,yk 合并为 P 的解。
 
## 5.分治法复杂性分析
分治法将规模为 n 的问题分成 k 个规模为 n/m 的子问题去解。
 - 设分解阈值 n0 = 1 ,且 Adhoc 解规模为1的问题耗费 1 个时间单位。
 - 再设将原问题分解为 k 个子问题以及用 Merge 将 k 个子问题的解合并为原问题的解需要 f(n) 个单位时间。
 
用 T(n) 表示该分支法解规模为 |p|=n 的问题所需的计算时间则有:
 ![](http://latex.codecogs.com/gif.latex?\T(n)=kT(n/m)+f(n))

通过迭代求解：认为 T(n) 足够平滑，那么由 n=2^m 时 T(n) 的值可以估计 T(n) 的增长速度。通常假定 T(n) 单调上升，从而:

![](http://latex.codecogs.com/gif.latex?\m_i<=n<m_i+1) 时，![](http://latex.codecogs.com/gif.latex?\T(m_i)<=T(n)<T(m_i+1))
 
## 6. 可使用分治法求解的一些经典问题
  - 二分搜索
  - 大整数乘法
  - Strassen 矩阵乘法
  - 棋盘覆盖
  - 合并排序
  - 快速排序
  - 线性时间选择
  - 最接近点对问题
  - 循环赛日程表
  - 汉诺塔问题

  ![](https://github.com/koala7580/weekCoding/blob/master/%E5%95%8A.gif)

啊啊啊，我是汉字搬运工 :) 这大段特别像大学考试前的划重点，就考这些了，还不快去背！

*参考链接*
[五大算法思想：分治、动态规划、贪心、回溯和分支界定](https://blog.csdn.net/KingCat666/article/details/73611009)

# 三、 动态规划  
## 1. 基本概念
动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。

## 2. 基本思想与策略
动态规划其实和分治策略是类似的，也是将一个原问题分解为若干个规模较小的子问题，递归的求解这些子问题，然后合并子问题的解得到原问题的解。

区别在于这些子问题会有重叠，一个子问题在求解后，可能会再次求解，于是我们想到 *将这些子问题的解存储起来* ，当下次再次求解这个子问题时，直接拿过来就是。

其实就是说，动态规划所解决的问题是分治策略所解决问题的一个子集，只是这个子集更适合用动态规划来解决从而得到更小的运行时间。 *即用动态规划能解决的问题分治策略肯定能解决，只是运行时间长了。* 因此，分治策略一般用来解决子问题相互对立的问题，称为标准分治，而动态规划用来解决子问题重叠的问题。

将「动态规划」的概念关键点抽离出来描述就是这样的：
```
1.动态规划法试图只解决每个子问题一次
2.一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。
```

## 3. 划重点

**动态规划** 中包含三个重要的概念：
 - 最优子结构
 - 边界
 - 状态转移公式
 
## 4. 示例：国王挖金矿问题 

```
有一个国家发现了 5 座金矿，每座金矿的黄金储量不同，需要参与挖掘的工人数也不同。
参与挖矿工人的总数是 10 人。每座金矿要么全挖，要么不挖，不能派出一半人挖取一半金矿。
要求用程序求解出，要想得到尽可能多的黄金，应该选择挖取哪几座金矿？
```
![](https://github.com/koala7580/weekCoding/blob/master/%E5%9B%BD%E7%8E%8B%E6%8C%96%E9%87%91%E7%9F%BF.png)

下面找出 动态规划 中的这三个概念：

**最优子结构**

![](https://github.com/koala7580/weekCoding/blob/master/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84.png)

有两个最优子结构：
 - 4金矿 10工人 的最优选择
 - 4金矿 （10-5）工人 的最优选择
 4 金矿的最优选择与 5 金矿的最优选择之间的关系是：
 
   ```MAX[（4 金矿 10 工人的挖金数量），（4 金矿 5 工人的挖金数量 + 第 5 座金矿的挖金数量）]```
 
**边界**

边界有两个：
 - 当只有 1 座金矿时，只能挖这座唯一的金矿，得到的黄金数量为该金矿的数量
 - 当给定的工人数量不够挖 1 座金矿时，获取的黄金数量为 0
 
 **状态转移公式**
 
我们把金矿数量设为 N，工人数设为 W，金矿的黄金量设为数组G[]，金矿的用工量设为数组P[]，得到 状态转移公式：
 - 边界值：F(n,w) = 0    (n <= 1, w < p[0])
```
F(n,w) = g[0] (n==1, w >= p[0])
F(n,w) = F(n-1,w)    (n > 1, w < p[n-1])
F(n,w) = max(F(n-1,w), F(n-1,w-p[n-1]) + g[n-1]) (n > 1, w >= p[n-1])
```

### code

方法具体思路看[小吴师兄的动图](https://juejin.im/post/5c2308abf265da615304ce41)吧，不能再清楚了。
下面是我改编的python实现
```python
//maxGold[i][j] 保存了i个人挖前j个金矿能够得到的最大金子数，等于 -1 时表示未知
maxGold = [ [-1 for i in range(max_n)] for j in range(max_people) ]  # 声明定长二维数组[max_people][max_n]

def GetMaxGold(people, mineNum):
    retMaxGold = 0
    if maxGold[people][mineNum] != -1:
        # 这个问题被计算过              
        retMaxGold = maxGold[people][mineNum]       # 返回记录值

    elif mineNum == 0:
        # 边界：仅有一个金矿                              
        if people >= peopleNeed[mineNum]:           
            retMaxGold = gold[mineNum]              # 人数足够挖矿 -> 挖
        else:
            retMaxGold = 0                          # 人数不够 -> 溜

    elif people >= peopleNeed[mineNum]:
        # 人数够：max(挖？不挖)
        retMaxGold = max( GetMaxGold(people-peopleNeed[mineNum], mineNum-1) + gold[mineNum],\
                          GetMaxGold(people, mineNum) )
    else :
        # 人数不够挖这个矿，只要前边已经挖过的
        retMaxGold = GetMaxGold(people, mineNum-1)
        maxGold[people][mineNum] = retMaxGold

    return retMaxGold
```

# 四、 贪心 回溯 分支限界

小吴师兄骗我，说好的后续我没找到 T^T 自己找了个博客，还是上边那个。很详细，但是特别像我们大学考试的重点，大段文字就不往这搬了。

[五大算法思想：分治、动态规划、贪心、回溯和分支界定](https://blog.csdn.net/KingCat666/article/details/73611009)

